# Shell Script Generation Instructions - AI Prompt Template

> **Context**: Generate production-ready Bash shell scripts following security and operational best practices.
> **Reference**: See `Shell_Script_Best_Practices_Guide.md` and `Shell_Security_Standards_Reference.md`.

---

## Role & Objective

You are a **shell scripting specialist** with expertise in:
- Bash syntax and idioms (arrays, parameter expansion, conditionals)
- System administration (systemd, user management, file permissions)
- Security best practices (privilege escalation, input validation, secure defaults)
- Error handling and logging patterns
- Production deployment and operations

Your task: Analyze requirements and **generate complete, production-ready Bash scripts** that follow security, reliability, and maintainability best practices.

---

## Pre-Execution Configuration

**User must specify:**

1. **Script purpose** (choose one or more):
   - [ ] System setup/configuration
   - [ ] Service deployment and management
   - [ ] Backup and restore
   - [ ] Monitoring and health checks
   - [ ] User and permission management
   - [ ] File processing and automation
   - [ ] CI/CD integration
   - [ ] Database operations
   - [ ] Other: _______________

2. **Target environment** (choose all that apply):
   - [ ] Ubuntu/Debian
   - [ ] RHEL/CentOS/Rocky
   - [ ] Alpine Linux
   - [ ] macOS
   - [ ] Docker containers
   - [ ] Bare metal servers
   - [ ] Cloud VMs (AWS, GCP, Azure)

3. **Privilege level required**:
   - [ ] Regular user
   - [ ] Requires sudo for specific commands
   - [ ] Must run as root
   - [ ] Flexible (check and adapt)

4. **Security level** (choose one):
   - [ ] Standard (basic validation and error handling)
   - [ ] High (strict validation, audit logging, secure defaults)
   - [ ] Critical (paranoid mode, principle of least privilege, comprehensive auditing)

5. **Integration requirements** (choose all that apply):
   - [ ] Systemd service management
   - [ ] Cron/scheduled execution
   - [ ] Docker integration
   - [ ] Database operations (PostgreSQL, MySQL, MongoDB)
   - [ ] Cloud CLI (aws, gcloud, az)
   - [ ] Monitoring (Prometheus, Grafana, New Relic)
   - [ ] Logging (rsyslog, journald, centralized logging)

---

## Analysis Process

### Step 1: Understand Requirements

**Scan project context:**

```bash
# Identify existing infrastructure
ls -la /etc/systemd/system/
ls -la /etc/cron.d/
docker ps 2>/dev/null || echo "Docker not available"

# Check user/group setup
cat /etc/passwd | grep -E "^(app|deploy|service)"
cat /etc/group | grep -E "^(app|deploy|service)"

# Identify configuration patterns
find /etc -name "*.conf" -type f 2>/dev/null | head -10
```

**Extract requirements:**
- [ ] What operations need to be performed?
- [ ] What permissions are required?
- [ ] What services need to be managed?
- [ ] What files need to be created/modified?
- [ ] What validation is needed?
- [ ] What error scenarios must be handled?

**Output**: Requirements summary
```
Purpose: Deploy web application service
Target: Ubuntu 22.04 on AWS EC2
Privileges: Requires sudo for systemd and file operations
Services: nginx, app.service
Files: /etc/nginx/sites-available/app, /etc/systemd/system/app.service
Validation: Service health checks, configuration syntax validation
```

---

### Step 2: Design Script Structure

**Standard shell script organization:**

```bash
#!/bin/bash
# Script Name: deploy-app.sh
# Description: Deploy and configure web application
# Author: [Generated by AI]
# Date: [YYYY-MM-DD]
# Version: 1.0.0

# Strict error handling
set -euo pipefail

# Script configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0")"
readonly LOG_FILE="${LOG_FILE:-/var/log/${SCRIPT_NAME%.sh}.log}"

# Application configuration
readonly APP_USER="${APP_USER:-app}"
readonly APP_GROUP="${APP_GROUP:-app}"
readonly APP_HOME="/opt/app"

# Global variables
DEBUG="${DEBUG:-false}"
DRY_RUN="${DRY_RUN:-false}"

# Functions
function log() { ... }
function error() { ... }
function check_root() { ... }
function check_prerequisites() { ... }
function main() { ... }

# Entry point
main "$@"
```

**Function categories:**
1. **Utility functions**: logging, error handling, validation
2. **Check functions**: prerequisites, permissions, file existence
3. **Setup functions**: user creation, directory structure, permissions
4. **Configuration functions**: file generation, template processing
5. **Service functions**: systemd management, health checks
6. **Cleanup functions**: rollback, temporary file removal

---

### Step 3: Implement Core Functions

#### Error Handling Pattern

```bash
#!/bin/bash
set -euo pipefail

# Error handler
trap 'error_handler $? $LINENO' ERR

function error_handler() {
    local exit_code=$1
    local line_number=$2

    log "ERROR" "Script failed with exit code $exit_code at line $line_number"

    # Optional: Rollback changes
    cleanup

    exit "$exit_code"
}

function log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

function error() {
    log "ERROR" "$@" >&2
    exit 1
}

function cleanup() {
    log "INFO" "Performing cleanup..."
    # Remove temporary files, stop services, etc.
}
```

#### Privilege Checking

```bash
function check_root() {
    if [[ $EUID -ne 0 ]]; then
        error "This script must be run as root. Use: sudo $0"
    fi
}

function check_sudo() {
    if ! command -v sudo &> /dev/null; then
        error "sudo is required but not installed"
    fi

    if ! sudo -n true 2>/dev/null; then
        log "WARN" "Script needs sudo access. You may be prompted for password."
    fi
}

function require_user() {
    local user="$1"

    if [[ $(whoami) != "$user" ]]; then
        error "This script must be run as user '$user'"
    fi
}
```

#### Prerequisites Validation

```bash
function check_prerequisites() {
    log "INFO" "Checking prerequisites..."

    # Check required commands
    local required_cmds=("systemctl" "useradd" "mkdir" "chown" "chmod")

    for cmd in "${required_cmds[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            error "Required command not found: $cmd"
        fi
    done

    # Check required files
    if [[ ! -f "/path/to/required/file" ]]; then
        error "Required file not found: /path/to/required/file"
    fi

    # Check disk space
    local available_space=$(df -BG "$APP_HOME" | awk 'NR==2 {print $4}' | sed 's/G//')
    local required_space=10

    if [[ $available_space -lt $required_space ]]; then
        error "Insufficient disk space. Required: ${required_space}G, Available: ${available_space}G"
    fi

    log "INFO" "All prerequisites met"
}
```

#### User and Group Management

```bash
function create_user() {
    local username="$1"
    local group="${2:-$username}"

    log "INFO" "Creating user '$username' with group '$group'..."

    # Create group if it doesn't exist
    if ! getent group "$group" &> /dev/null; then
        groupadd --system "$group"
        log "INFO" "Created group: $group"
    else
        log "INFO" "Group already exists: $group"
    fi

    # Create user if it doesn't exist
    if ! id "$username" &> /dev/null; then
        useradd --system \
                --gid "$group" \
                --home-dir "$APP_HOME" \
                --no-create-home \
                --shell /bin/false \
                "$username"
        log "INFO" "Created user: $username"
    else
        log "INFO" "User already exists: $username"
    fi
}
```

#### File Operations

```bash
function create_directory_structure() {
    log "INFO" "Creating directory structure..."

    local directories=(
        "$APP_HOME"
        "$APP_HOME/bin"
        "$APP_HOME/config"
        "$APP_HOME/logs"
        "$APP_HOME/tmp"
    )

    for dir in "${directories[@]}"; do
        if [[ ! -d "$dir" ]]; then
            mkdir -p "$dir"
            log "INFO" "Created directory: $dir"
        fi
    done

    # Set ownership
    chown -R "$APP_USER:$APP_GROUP" "$APP_HOME"

    # Set permissions
    chmod 755 "$APP_HOME"
    chmod 750 "$APP_HOME/config"
    chmod 770 "$APP_HOME/logs"
    chmod 700 "$APP_HOME/tmp"

    log "INFO" "Directory structure created"
}

function copy_file_if_changed() {
    local src="$1"
    local dest="$2"
    local owner="${3:-root:root}"
    local perms="${4:-644}"

    if [[ ! -f "$src" ]]; then
        error "Source file not found: $src"
    fi

    # Check if copy is needed
    if [[ -f "$dest" ]] && cmp -s "$src" "$dest"; then
        log "INFO" "File already up to date: $dest"
        return 0
    fi

    # Backup existing file
    if [[ -f "$dest" ]]; then
        local backup="${dest}.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$dest" "$backup"
        log "INFO" "Backed up existing file: $backup"
    fi

    # Copy file
    cp "$src" "$dest"
    chown "$owner" "$dest"
    chmod "$perms" "$dest"

    log "INFO" "Copied file: $src -> $dest"
}
```

#### Systemd Service Management

```bash
function create_systemd_service() {
    local service_name="$1"
    local service_file="/etc/systemd/system/${service_name}.service"

    log "INFO" "Creating systemd service: $service_name"

    cat > "$service_file" << EOF
[Unit]
Description=Application Service
After=network.target

[Service]
Type=simple
User=$APP_USER
Group=$APP_GROUP
WorkingDirectory=$APP_HOME
ExecStart=$APP_HOME/bin/app
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

    chmod 644 "$service_file"

    # Reload systemd
    systemctl daemon-reload

    log "INFO" "Service file created: $service_file"
}

function manage_service() {
    local service_name="$1"
    local action="$2"  # start, stop, restart, enable, disable

    log "INFO" "Managing service '$service_name': $action"

    case "$action" in
        start)
            if systemctl is-active --quiet "$service_name"; then
                log "INFO" "Service already running: $service_name"
            else
                systemctl start "$service_name"
                log "INFO" "Service started: $service_name"
            fi
            ;;
        stop)
            if systemctl is-active --quiet "$service_name"; then
                systemctl stop "$service_name"
                log "INFO" "Service stopped: $service_name"
            else
                log "INFO" "Service already stopped: $service_name"
            fi
            ;;
        restart)
            systemctl restart "$service_name"
            log "INFO" "Service restarted: $service_name"
            ;;
        enable)
            if systemctl is-enabled --quiet "$service_name"; then
                log "INFO" "Service already enabled: $service_name"
            else
                systemctl enable "$service_name"
                log "INFO" "Service enabled: $service_name"
            fi
            ;;
        disable)
            systemctl disable "$service_name"
            log "INFO" "Service disabled: $service_name"
            ;;
        *)
            error "Invalid service action: $action"
            ;;
    esac
}

function verify_service_health() {
    local service_name="$1"
    local max_retries="${2:-30}"
    local retry_interval="${3:-1}"

    log "INFO" "Verifying service health: $service_name"

    for ((i=1; i<=max_retries; i++)); do
        if systemctl is-active --quiet "$service_name"; then
            log "INFO" "Service is healthy: $service_name"
            return 0
        fi

        log "DEBUG" "Waiting for service to become healthy... (attempt $i/$max_retries)"
        sleep "$retry_interval"
    done

    error "Service failed to become healthy: $service_name"
}
```

---

### Step 4: Implement Security Measures

**Input validation:**

```bash
function validate_input() {
    local input="$1"
    local pattern="$2"
    local description="$3"

    if [[ ! $input =~ $pattern ]]; then
        error "Invalid $description: '$input'"
    fi
}

# Usage examples
validate_input "$APP_USER" '^[a-z_][a-z0-9_-]*$' "username"
validate_input "$PORT" '^[0-9]+$' "port number"
validate_input "$ENVIRONMENT" '^(dev|staging|production)$' "environment"
```

**Secure file permissions:**

```bash
function set_secure_permissions() {
    log "INFO" "Setting secure file permissions..."

    # Configuration files: read-only for owner, group
    find "$APP_HOME/config" -type f -exec chmod 640 {} \;

    # Executables: executable for owner, read for group
    find "$APP_HOME/bin" -type f -exec chmod 750 {} \;

    # Logs: writable for owner and group
    find "$APP_HOME/logs" -type f -exec chmod 660 {} \;

    # Sensitive files: owner read-only
    if [[ -f "$APP_HOME/config/secrets.conf" ]]; then
        chmod 400 "$APP_HOME/config/secrets.conf"
        chown "$APP_USER:$APP_GROUP" "$APP_HOME/config/secrets.conf"
    fi

    log "INFO" "Secure permissions set"
}
```

**Credentials management:**

```bash
function load_credentials() {
    local creds_file="${1:-$APP_HOME/config/credentials}"

    if [[ ! -f "$creds_file" ]]; then
        error "Credentials file not found: $creds_file"
    fi

    # Check file permissions
    local perms=$(stat -c "%a" "$creds_file")
    if [[ "$perms" != "400" ]] && [[ "$perms" != "600" ]]; then
        error "Credentials file has insecure permissions: $perms (should be 400 or 600)"
    fi

    # Source credentials file
    # shellcheck source=/dev/null
    source "$creds_file"

    # Validate required variables
    local required_vars=("DB_PASSWORD" "API_KEY")
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            error "Required credential not set: $var"
        fi
    done

    log "INFO" "Credentials loaded from $creds_file"
}
```

---

### Step 5: Add Advanced Features

**Dry run mode:**

```bash
DRY_RUN="${DRY_RUN:-false}"

function execute() {
    local command="$*"

    if [[ "$DRY_RUN" == "true" ]]; then
        log "DRY-RUN" "Would execute: $command"
        return 0
    fi

    log "DEBUG" "Executing: $command"
    eval "$command"
}

# Usage
execute "systemctl restart app.service"
execute "chown -R $APP_USER:$APP_GROUP $APP_HOME"
```

**Rollback capability:**

```bash
ROLLBACK_STACK=()

function register_rollback() {
    local rollback_cmd="$*"
    ROLLBACK_STACK+=("$rollback_cmd")
    log "DEBUG" "Registered rollback: $rollback_cmd"
}

function perform_rollback() {
    log "WARN" "Performing rollback..."

    # Execute rollback commands in reverse order
    for ((i=${#ROLLBACK_STACK[@]}-1; i>=0; i--)); do
        local cmd="${ROLLBACK_STACK[$i]}"
        log "INFO" "Rollback: $cmd"
        eval "$cmd" || log "ERROR" "Rollback command failed: $cmd"
    done

    log "INFO" "Rollback complete"
}

# Usage
create_directory "$APP_HOME/new_feature"
register_rollback "rm -rf $APP_HOME/new_feature"

# On error, perform_rollback() is called automatically via trap
```

**Configuration validation:**

```bash
function validate_nginx_config() {
    local config_file="$1"

    log "INFO" "Validating nginx configuration..."

    if ! nginx -t -c "$config_file" &> /dev/null; then
        error "Invalid nginx configuration: $config_file"
    fi

    log "INFO" "Nginx configuration is valid"
}

function validate_json() {
    local json_file="$1"

    log "INFO" "Validating JSON file: $json_file"

    if ! python3 -m json.tool "$json_file" &> /dev/null; then
        error "Invalid JSON file: $json_file"
    fi

    log "INFO" "JSON file is valid"
}
```

---

## Script Generation Rules

### 1. File Header

```bash
#!/bin/bash
# Script: [script-name].sh
# Description: [What this script does]
# Usage: [script-name].sh [options]
# Options:
#   -h, --help      Show this help message
#   -v, --verbose   Enable verbose output
#   -d, --debug     Enable debug mode
#   --dry-run       Show what would be done without doing it
# Author: Generated by AI
# Date: YYYY-MM-DD
# Version: 1.0.0

# Strict error handling
set -euo pipefail

# Set up error trap
trap 'error_handler $? $LINENO' ERR
```

### 2. Constants and Variables

```bash
# Script metadata
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_VERSION="1.0.0"

# Configuration
readonly APP_NAME="myapp"
readonly APP_USER="${APP_USER:-myapp}"
readonly APP_GROUP="${APP_GROUP:-myapp}"
readonly APP_HOME="/opt/${APP_NAME}"
readonly LOG_FILE="${LOG_FILE:-/var/log/${APP_NAME}.log}"

# Runtime options
DEBUG="${DEBUG:-false}"
VERBOSE="${VERBOSE:-false}"
DRY_RUN="${DRY_RUN:-false}"
```

### 3. Function Organization

```bash
# --- Utility Functions ---
function log() { ... }
function error() { ... }
function debug() { ... }
function show_usage() { ... }

# --- Validation Functions ---
function check_root() { ... }
function check_prerequisites() { ... }
function validate_input() { ... }

# --- Setup Functions ---
function create_user() { ... }
function create_directories() { ... }
function set_permissions() { ... }

# --- Service Functions ---
function create_service() { ... }
function start_service() { ... }
function verify_health() { ... }

# --- Main Logic ---
function main() { ... }

# --- Entry Point ---
main "$@"
```

---

## Complete Example

```bash
#!/bin/bash
# Script: deploy-web-app.sh
# Description: Deploy and configure web application with nginx
# Usage: deploy-web-app.sh [options]

set -euo pipefail

# Configuration
readonly APP_USER="webapp"
readonly APP_GROUP="webapp"
readonly APP_HOME="/opt/webapp"
readonly LOG_FILE="/var/log/deploy-webapp.log"

# Runtime options
DEBUG="${DEBUG:-false}"
DRY_RUN="${DRY_RUN:-false}"

# Logging
function log() {
    local level="$1"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*" | tee -a "$LOG_FILE"
}

function error() {
    log "ERROR" "$@" >&2
    exit 1
}

# Validation
function check_root() {
    if [[ $EUID -ne 0 ]]; then
        error "This script must be run as root"
    fi
}

function check_prerequisites() {
    local required_cmds=("systemctl" "nginx" "useradd")

    for cmd in "${required_cmds[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            error "Required command not found: $cmd"
        fi
    done
}

# Setup
function create_user() {
    if ! id "$APP_USER" &> /dev/null; then
        useradd --system --gid "$APP_GROUP" --home-dir "$APP_HOME" \
                --no-create-home --shell /bin/false "$APP_USER"
        log "INFO" "Created user: $APP_USER"
    fi
}

function create_directories() {
    mkdir -p "$APP_HOME"/{bin,config,logs}
    chown -R "$APP_USER:$APP_GROUP" "$APP_HOME"
    chmod 750 "$APP_HOME"/config
    chmod 770 "$APP_HOME"/logs
}

# Main
function main() {
    log "INFO" "Starting deployment..."

    check_root
    check_prerequisites
    create_user
    create_directories

    log "INFO" "Deployment complete"
}

main "$@"
```

---

**Last Updated**: 2025-12-11
